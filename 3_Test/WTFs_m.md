# WTFs_m
[TOC]
- WTFs/minuts
# 爛代碼產生的原因和現象
## 爛代碼的特徵
- 意義不明:
    - 不知道自己究竟在做什麼的代碼
- 不說人話:
    - 一段很簡單的代碼其他人卻看不懂
- 不洽當的組織
    - 有基本的代碼風格，但是對於規模大一些的工程掌控能力不夠，不知道代碼應該如何解耦、分層和組織
    - 一段代碼在工程裡拷來拷去，某個文件放了一大坨堆砌起來的代碼、一個函數堆了幾百上千行，一個簡單的功能七拐八繞的調了幾十個函數
- 假設和缺少抽象
    - 代碼很難復用
    - 寫代碼的時候來不及考慮復用、代碼難復用導致之後的需求還要繼續寫大量的代碼
- 總結:
    - 三個層次
        - 只是一個人維護的代碼，滿足功能和性能要求倒也足夠
        - 在一個團隊裡工作，那就必須易於理解和測試，讓其他人員有能力修改各自的代碼
        - 越是處於底層的代碼擴展性也越重要
- 夠用的代碼:
    - 幾乎所有的爛代碼都是從夠用的代碼演化來的，代碼沒變，使用代碼的場景發生改變，原本夠用的代碼不符合新的場景，那麼他就成了爛代碼
## 重構的難處
- 重構代碼時:
    - 理解舊代碼
    - 分解舊代碼
    - 構建新代碼
- 重構的複雜度跟代碼的複雜度不是線性相關的
    - 重構1000行爛代碼可能要1小時
    - 重構5000行爛代碼可能要2、3天
- 現象:
    - 基本關於重購的書籍無一例外都會有獨立章節介紹如何向boss說明重購的必要性
- 例子:
    - 重構之後能提升多少效率?能降低多少風險?很難答上來，爛代碼本身就不是一個可以簡單的標準化的東西
## 寫好代碼很難
- 寫出好代碼的前提
    - 理解要開發的功能需求
    - 了解程序的運行原裡
    - 做出合理的抽象
    - 組織複雜的邏輯
    - 對自己開發效率的正確估算
    - 持續不斷的練習
## 範例:
- [ ] 寫一個代碼行數統計工具
    - 按文件類型統計行數
    - 要求提高統計效率
    - 統計的同時輸出某些單詞出現的次數
- 考察:
    - [ ] 基本的樹的遍歷算法
# 好的代碼應該是什麼樣
## 什麼是好代碼
- 定義(on CleanCode)
- 對於代碼的質量的定義需要從兩個維度分析
    - 主觀的，被人理解的部分
    - 客觀的，計算機運行的情況
- 難處:
    - 存在主觀那麼就會存在個體差異，對於同一段代碼評價因看代碼的人的水平不同而得出不一樣結論，這也是大多數新人面對的問題: 他們沒有一個可以執行的評價標準，所以寫出來的代碼質量也很難提高
## 可讀的代碼
- 將代碼逐字翻譯
- 遵循約定
    - 代碼和文檔如何組織
    - 注釋如何編寫
    - 編碼風格的約定
    - 大部分情況下跟著google做應該不會有什麼大問題
- 文檔和注釋
    - 理解一個工程或項目的途徑之一
    - 比較關心的幾類文檔
        - 對於項目的介紹
            - 功能、作者、目錄結構，讀者應該能3分鐘內大致理解這個功能是做什麼的
        - 對於新人的QuickStart
            - 按照文檔說明應該能在1小時內完成代碼構建和簡單的使用
        - 針對使用者的詳細說明文檔
            - 接口定義
            - 參數涵義
            - 設計
    - 一部分注釋實際是文檔
    - 一類注釋並不作為文檔的一部分
        - 比如函數內部的注釋
        - 說明一些代碼本身無碼表達的作者在編碼時的思考
## 可發布的代碼
- 處理異常
    - 單元測試以及覆蓋率
- 處理併發
- 優化性能
    - 算法的時間複雜度
    - 單步操作耗時
- 日誌
## 可維護的代碼
- 避免重複
- 信息重複
    - 隨著項目的演進，無用的信息會越積越多，甚至無法分辨哪些信息是有效的，哪些是無效的
- 模塊劃分
- 簡潔與抽象
# 如何應對身邊的爛代碼
## 改善可維護性
- 重構的悖論
    - 開發講究快速迭代，如果要做大型重構，往往需要暫停需求開發，這個基本上很難實現
    - 沒什麼新需求的項目，往往意味著項目本身已經過了發展期，即使做了重構也帶來不了什麼收益
- 重構step by step
    - 開始之前
        - 小規模的重構應該跟敲代碼一樣屬於日常開發的一部分
    - 隨時進行模塊內部的重構
        - 把一個巨大無比的函數拆分成可維護的小塊代碼
            - 重命名變量
            - 重命名函數
            - 提取內部函數
            - 提取內部常數
            - 提取變量
        - 這類重構的收益主要是提高函數級別的可讀性，以及消除超大函數
    - 一次只做一個較模塊級別的重構
        - 包含:
            - 刪除無用代碼
            - 移動函數到其他類
            - 提取函數到新類
            - 修改函數邏輯
        - 這類重構主要在於優化代碼的設計
        - 這類重構期間你需要創建大量的類和新的單元測試
- 重構的週期
    - 在正常需求開發的同時進行模塊內部的重構，同時理解功能原有代碼
    - 在需求間隙進行模塊級別的重構，把大模塊拆分為多個小模塊、補充單元測試
    - tips:
        - 只重構經常修改的部分
        - 抑制住自己想要多改一點的衝動
        - 重構需要不斷的練習，相比於寫代碼來說，重構或許更難依些
        - 重構可能需要很長時間，主要取決於團隊對於風險的容忍程度
        - 刪除無用代碼是提高代碼可維護性最有效的方式
        - 單元測試是重構的基礎
## 改善性能與健壯性
- 改善性能的80%
    - 優化主要部分
    - 性能優化之後要有量化數據
## 改善生存環境
- 統一環境
- 代碼倉庫
- 持續反饋
    - 靜態檢查工具
        - checkstyle
        - findbug
    - 趨勢:
        - 每天都在產生大量的新代碼
        - 測試覆蓋率下降
        - 靜態檢查的問題增多
- 質量文化:
    - 爛代碼無法避免
    - 爛代碼無法接受
    - 爛代碼可以改進
    - 好的代碼能讓工作更開心一些
# reference
- [爛代碼的那些事(上)](http://blog.2baxb.me/archives/1343)
- [爛代碼的那些事(中)](http://blog.2baxb.me/archives/1378)
- [爛代碼的那些事(下)](http://blog.2baxb.me/archives/1499)